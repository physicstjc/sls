<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kinematics Graph Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        canvas { touch-action: none; }
        
        /* Graph Card Styling */
        .graph-card { 
            border: 1px solid #e5e7eb; 
            border-radius: 0.5rem; 
            background: #fff; 
            display: flex; 
            flex-direction: column; 
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            /* Allow height to grow */
            height: auto;
            min-height: min-content;
            flex-shrink: 0; 
        }
        
        .graph-header {
            padding: 6px 12px;
            border-bottom: 1px solid #f3f4f6;
            background: #f9fafb;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .graph-canvas-container { 
            position: relative; 
            height: 160px; 
            width: 100%; 
            border-bottom: 1px solid #f3f4f6; 
        }
        
        .graph-footer { 
            background: #fff; 
            padding: 8px 12px; 
            font-size: 0.75rem; 
            color: #4b5563; 
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; 
            line-height: 1.6; 
            min-height: 40px; /* Ensure space for formula */
        }
        
        /* Custom Slider Styling */
        .slider-thumb { -webkit-appearance: none; appearance: none; width: 100%; height: 6px; background: transparent; outline: none; z-index: 20; position: relative; }
        .slider-thumb::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; border-radius: 50%; background: #3b82f6; cursor: pointer; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3); margin-top: -5px; }
        .slider-thumb::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; background: #3b82f6; cursor: pointer; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3); }
        .slider-track-bg { position: absolute; top: 50%; left: 0; width: 100%; height: 6px; background: #e5e7eb; transform: translateY(-50%); border-radius: 3px; z-index: 0; }

        /* Time Scrubber Specifics */
        .time-scrubber::-webkit-slider-thumb { background: #ef4444; width: 20px; height: 20px; margin-top: -7px; transition: transform 0.1s; }
        .time-scrubber::-webkit-slider-thumb:hover { transform: scale(1.1); }
        .time-scrubber::-moz-range-thumb { background: #ef4444; width: 20px; height: 20px; }

        /* Markers */
        .event-marker { position: absolute; top: 50%; transform: translate(-50%, -50%); width: 12px; height: 12px; border-radius: 50%; z-index: 30; cursor: pointer; transition: all 0.2s; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .event-marker:hover { transform: translate(-50%, -50%) scale(1.3); z-index: 40; }
        .marker-bounce { background-color: #ef4444; top: 120%; border-radius: 0 50% 50% 50%; transform: translate(-50%, 0) rotate(45deg); }
        .marker-peak { background-color: #10b981; top: -20%; border-radius: 50% 50% 50% 0; transform: translate(-50%, -100%) rotate(45deg); }
        
        /* Tooltip for Markers */
        .event-marker::after { content: attr(data-label); position: absolute; bottom: 140%; left: 50%; transform: translateX(-50%) rotate(-45deg); background: rgba(0,0,0,0.8); color: white; padding: 4px 8px; border-radius: 4px; font-size: 10px; white-space: nowrap; opacity: 0; pointer-events: none; transition: opacity 0.2s; }
        .marker-bounce::after { bottom: auto; top: 140%; transform: translateX(-50%) rotate(-45deg); }
        .event-marker:hover::after { opacity: 1; }

        /* Calculation Formula Style */
        .calc-formula { 
            display: block; 
            margin-top: 4px; 
            color: #6b7280; 
            font-size: 0.7rem; 
            white-space: pre-wrap; /* Ensure text wraps but preserves line breaks */
            word-break: break-word;
            line-height: 1.6;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="bg-white border-b border-gray-200 px-6 py-3 flex items-center justify-between shadow-sm z-10 flex-shrink-0">
        <div class="flex items-center gap-3">
            <div class="bg-blue-600 text-white p-2 rounded-lg">
                <i class="fas fa-chart-line"></i>
            </div>
            <h1 class="text-xl font-bold tracking-tight text-gray-900">Kinematics Explorer</h1>
        </div>
        <div class="flex items-center gap-4">
            <button onclick="toggleDirection()" id="dirBtn" class="flex items-center gap-2 px-3 py-1.5 text-sm font-medium bg-gray-100 hover:bg-gray-200 rounded-md transition-colors border border-gray-300">
                <i class="fas fa-arrows-alt-v"></i>
                <span>Positive: UP</span>
            </button>
            <div class="h-6 w-px bg-gray-300"></div>
            <button onclick="resetSimulation()" class="text-gray-600 hover:text-blue-600 transition-colors" title="Reset">
                <i class="fas fa-undo"></i>
            </button>
            <button onclick="togglePlay()" id="playBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-md font-medium transition-colors shadow-sm flex items-center gap-2">
                <i class="fas fa-play"></i> Start
            </button>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden">
        
        <!-- Sidebar Controls -->
        <aside class="w-80 bg-white border-r border-gray-200 flex flex-col overflow-y-auto z-10 shadow-[4px_0_24px_rgba(0,0,0,0.02)] flex-shrink-0">
            <div class="p-5 space-y-6">
                
                <!-- Presets -->
                <div>
                    <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3">Scenarios</h3>
                    <div class="grid grid-cols-2 gap-2">
                        <button onclick="setPreset('constV')" class="p-2 text-sm border rounded hover:bg-blue-50 hover:border-blue-200 text-left transition">Const. Velocity</button>
                        <button onclick="setPreset('constA')" class="p-2 text-sm border rounded hover:bg-blue-50 hover:border-blue-200 text-left transition">Const. Accel</button>
                        <button onclick="setPreset('incAccel')" class="p-2 text-sm border rounded hover:bg-blue-50 hover:border-blue-200 text-left transition">Inc. Accel</button>
                        <button onclick="setPreset('decAccel')" class="p-2 text-sm border rounded hover:bg-blue-50 hover:border-blue-200 text-left transition">Dec. Accel</button>
                        <button onclick="setPreset('drop')" class="p-2 text-sm border rounded hover:bg-blue-50 hover:border-blue-200 text-left transition">Free Fall</button>
                        <button onclick="setPreset('throw')" class="p-2 text-sm border rounded hover:bg-blue-50 hover:border-blue-200 text-left transition">Throw Up</button>
                        <button onclick="setPreset('bounceElastic')" class="p-2 text-sm border rounded hover:bg-blue-50 hover:border-blue-200 text-left transition">Elastic Bounce</button>
                        <button onclick="setPreset('bounceInelastic')" class="p-2 text-sm border rounded hover:bg-blue-50 hover:border-blue-200 text-left transition">Inelastic Bounce</button>
                    </div>
                </div>

                <!-- Parameters -->
                <div>
                    <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-4">Initial Conditions</h3>
                    
                    <div class="space-y-4">
                        <div>
                            <div class="flex justify-between text-sm mb-1">
                                <label>Initial Position (y₀)</label>
                                <span class="font-mono text-blue-600" id="val_y0">0 m</span>
                            </div>
                            <div class="relative h-6">
                                <div class="slider-track-bg"></div>
                                <input type="range" min="0" max="100" value="0" id="input_y0" class="slider-thumb" oninput="updateParams()">
                            </div>
                        </div>

                        <div>
                            <div class="flex justify-between text-sm mb-1">
                                <label>Initial Velocity (v₀)</label>
                                <span class="font-mono text-blue-600" id="val_v0">0 m/s</span>
                            </div>
                            <div class="relative h-6">
                                <div class="slider-track-bg"></div>
                                <input type="range" min="-50" max="50" value="0" id="input_v0" class="slider-thumb" oninput="updateParams()">
                            </div>
                        </div>

                        <div>
                            <div class="flex justify-between text-sm mb-1">
                                <label>Acceleration (a)</label>
                                <span class="font-mono text-blue-600" id="val_a">0 m/s²</span>
                            </div>
                            <div class="relative h-6">
                                <div class="slider-track-bg"></div>
                                <input type="range" min="-20" max="20" step="0.5" value="0" id="input_a" class="slider-thumb" oninput="updateParams()">
                            </div>
                        </div>

                        <div>
                            <div class="flex justify-between text-sm mb-1">
                                <label>Bounciness (e)</label>
                                <span class="font-mono text-blue-600" id="val_e">0.8</span>
                            </div>
                            <div class="relative h-6">
                                <div class="slider-track-bg"></div>
                                <input type="range" min="0" max="1" step="0.1" value="0.8" id="input_e" class="slider-thumb" oninput="updateParams()">
                            </div>
                            <p class="text-xs text-gray-400 mt-1">1.0 = No Energy Loss</p>
                        </div>
                    </div>
                </div>

                <div class="pt-4 border-t border-gray-100">
                    <div class="bg-blue-50 p-3 rounded text-xs text-blue-800 leading-relaxed">
                        <i class="fas fa-info-circle mr-1"></i>
                        <strong>Tip:</strong> Toggle "Positive Direction" to see how vector graphs (Left Column) flip, while scalar graphs (Right Column) remain additive.
                    </div>
                    <div class="mt-4 text-[11px] text-gray-400 text-center font-medium">
                        Made by James Kua, Temasek Junior College
                    </div>
                </div>
            </div>
        </aside>

        <!-- Main Workspace -->
        <main class="flex-1 flex flex-col bg-gray-50 overflow-hidden">
            
            <div class="flex flex-1 overflow-hidden">
                <!-- Animation Canvas (Left center) -->
                <div class="w-1/3 h-full p-4 flex flex-col border-r border-gray-200 bg-white relative flex-shrink-0">
                    <h3 class="text-sm font-semibold text-gray-500 mb-2 flex items-center gap-2">
                        <i class="fas fa-film"></i> Animation
                    </h3>
                    <div class="flex-1 relative bg-gray-50 border border-gray-200 rounded-lg overflow-hidden" id="animContainer">
                        <!-- Ground -->
                        <div class="absolute bottom-0 w-full h-4 bg-gray-300 border-t border-gray-400 z-0"></div>
                        <!-- Canvas -->
                        <canvas id="animCanvas" class="w-full h-full z-10 block"></canvas>
                        
                        <!-- Axis Labels -->
                        <div class="absolute left-2 top-2 text-xs text-gray-400 font-mono">100m</div>
                        <div class="absolute left-2 bottom-6 text-xs text-gray-400 font-mono">0m</div>
                    </div>
                </div>

                <!-- Graphs Grid (Right) -->
                <div class="w-2/3 h-full overflow-y-auto p-6 bg-gray-50">
                    <div class="grid grid-cols-2 gap-x-6 gap-y-6 max-w-5xl mx-auto">
                        
                        <!-- Headers -->
                        <div class="text-center pb-2 border-b-2 border-blue-500">
                            <h2 class="text-sm font-bold text-gray-800 uppercase tracking-wide">Vector Quantities (Direction Matters)</h2>
                        </div>
                        <div class="text-center pb-2 border-b-2 border-green-500">
                            <h2 class="text-sm font-bold text-gray-800 uppercase tracking-wide">Scalar Quantities (Magnitude Only)</h2>
                        </div>

                        <!-- Row 1: Displacement vs Distance -->
                        <div class="graph-card">
                            <div class="graph-header text-blue-600">Displacement - Time</div>
                            <div class="graph-canvas-container">
                                <canvas id="dispGraph" class="w-full h-full"></canvas>
                            </div>
                            <div class="graph-footer">
                                <div class="flex justify-between items-center">
                                    <span class="text-gray-500">Gradient (Velocity):</span>
                                    <span class="font-bold text-blue-700" id="calc-disp-grad">--</span>
                                </div>
                            </div>
                        </div>

                        <div class="graph-card">
                            <div class="graph-header text-green-600">Distance - Time</div>
                            <div class="graph-canvas-container">
                                <canvas id="distGraph" class="w-full h-full"></canvas>
                            </div>
                        </div>

                        <!-- Row 2: Velocity vs Speed -->
                        <div class="graph-card">
                            <div class="graph-header text-blue-600">Velocity - Time</div>
                            <div class="graph-canvas-container">
                                <canvas id="velGraph" class="w-full h-full"></canvas>
                            </div>
                            <div class="graph-footer">
                                <div class="flex justify-between items-center border-b border-gray-100 pb-1 mb-1">
                                    <span class="text-gray-500">Gradient (Accel):</span>
                                    <span class="font-bold text-blue-700" id="calc-vel-grad">--</span>
                                </div>
                                <div>
                                    <div class="flex justify-between items-center">
                                        <span class="text-gray-500">Area (Change in Disp):</span>
                                        <span class="font-bold text-blue-700" id="calc-vel-area">--</span>
                                    </div>
                                    <span class="calc-formula" id="calc-vel-formula"></span>
                                </div>
                            </div>
                        </div>

                        <div class="graph-card">
                            <div class="graph-header text-green-600">Speed - Time</div>
                            <div class="graph-canvas-container">
                                <canvas id="spdGraph" class="w-full h-full"></canvas>
                            </div>
                        </div>

                        <!-- Row 3: Acceleration -->
                        <div class="graph-card">
                            <div class="graph-header text-blue-600">Acceleration - Time</div>
                            <div class="graph-canvas-container">
                                <canvas id="accGraph" class="w-full h-full"></canvas>
                            </div>
                            <div class="graph-footer">
                                <div class="flex justify-between items-center">
                                    <span class="text-gray-500">Area (Change in Vel):</span>
                                    <span class="font-bold text-blue-700" id="calc-acc-area">--</span>
                                </div>
                            </div>
                        </div>

                        <div class="flex items-center justify-center text-center p-4 text-gray-400 text-sm italic border border-dashed border-gray-300 rounded h-full">
                            Scalars don't have a specific "Acceleration" equivalent graph typically taught at this level.
                        </div>

                    </div>
                    <div class="h-10"></div> <!-- Spacer -->
                </div>
            </div>

            <!-- Timeline Scrubber -->
            <div class="h-20 bg-white border-t border-gray-200 px-6 flex items-center gap-4 z-20 shrink-0 select-none flex-shrink-0">
                <button onclick="togglePlay()" id="scrubPlayBtn" class="text-gray-500 hover:text-blue-600 transition-colors w-8">
                    <i class="fas fa-play text-lg"></i>
                </button>
                
                <!-- Track Container -->
                <div class="flex-1 relative group h-8 flex items-center">
                    
                    <!-- Markers Container (Behind Input) -->
                    <div id="timelineMarkers" class="absolute top-0 left-0 w-full h-full pointer-events-none">
                        <!-- Markers injected via JS -->
                    </div>

                    <!-- Visual Track Background -->
                    <div class="absolute top-1/2 left-0 w-full h-2 bg-gray-200 rounded-lg transform -translate-y-1/2 z-0"></div>

                    <!-- Range Input -->
                    <input type="range" min="0" max="100" value="0" step="0.1" id="timeScrubber" class="slider-thumb time-scrubber w-full h-full cursor-pointer z-10" oninput="scrub(this.value)">
                    
                    <!-- Time Labels -->
                    <div class="absolute top-6 w-full flex justify-between text-xs text-gray-400 px-1 pointer-events-none">
                        <span>0.0s</span>
                        <span>5.0s</span>
                        <span>10.0s</span>
                    </div>
                </div>

                <div class="font-mono text-lg font-bold text-blue-600 w-20 text-right" id="timeDisplay">
                    0.00s
                </div>
            </div>

        </main>
    </div>

    <script>
        // --- State Management ---
        const CONSTANTS = {
            dt: 0.016, // Physics time step
            simDuration: 10, // Max simulation time in seconds
            maxY: 100 // Height of simulation world in meters
        };

        const state = {
            running: false,
            currentTime: 0,
            
            // Simulation Parameters
            params: {
                y0: 0,
                v0: 0,
                a: 0,
                jerk: 0, // Rate of change of acceleration
                restitution: 0.8,
                positiveUp: true,
                preserveJerk: false
            },

            // Pre-calculated Trajectory Data
            trajectory: { t: [], y: [], v: [], a: [], d: [], s: [] },
            events: [], // Stores { time, type, vIn, vOut }
            
            // Canvas Contexts
            animCtx: null,
            graphs: {}
        };

        // --- Initialization ---
        window.onload = function() {
            setupCanvas('animCanvas');
            state.animCtx = document.getElementById('animCanvas').getContext('2d');
            
            const graphIds = ['dispGraph', 'velGraph', 'accGraph', 'distGraph', 'spdGraph'];
            graphIds.forEach(id => {
                setupCanvas(id);
                state.graphs[id] = document.getElementById(id).getContext('2d');
            });

            updateParams(); 
            setPreset('drop');

            window.addEventListener('resize', () => {
                setupCanvas('animCanvas');
                graphIds.forEach(id => setupCanvas(id));
                drawFrame();
            });
        };

        function setupCanvas(id) {
            const canvas = document.getElementById(id);
            const parent = canvas.parentElement;
            canvas.width = parent.clientWidth * window.devicePixelRatio;
            canvas.height = parent.clientHeight * window.devicePixelRatio;
            const ctx = canvas.getContext('2d');
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            canvas.logicalWidth = parent.clientWidth;
            canvas.logicalHeight = parent.clientHeight;
        }

        // --- Controls ---

        function updateParams() {
            state.params.y0 = parseFloat(document.getElementById('input_y0').value);
            state.params.v0 = parseFloat(document.getElementById('input_v0').value);
            state.params.a = parseFloat(document.getElementById('input_a').value);
            state.params.restitution = parseFloat(document.getElementById('input_e').value);
            
            if (!state.params.preserveJerk) {
                state.params.jerk = 0;
            }
            state.params.preserveJerk = false; 

            // Update UI Labels
            document.getElementById('val_y0').textContent = `${state.params.y0} m`;
            document.getElementById('val_v0').textContent = `${state.params.v0} m/s`;
            document.getElementById('val_a').textContent = `${state.params.a} m/s²`;
            document.getElementById('val_e').textContent = state.params.restitution;

            runSimulation();
            
            if (!state.running) {
                state.currentTime = 0;
                updateScrubberUI();
                drawFrame();
            }
        }

        function resetSimulation() {
            state.running = false;
            updatePlayButton();
            state.currentTime = 0;
            updateScrubberUI();
            drawFrame();
        }

        function togglePlay() {
            state.running = !state.running;
            updatePlayButton();
            if (state.running) {
                if (state.currentTime >= CONSTANTS.simDuration) {
                    state.currentTime = 0;
                }
                requestAnimationFrame(animationLoop);
            }
        }

        function updatePlayButton() {
            const btn = document.getElementById('playBtn');
            const scrubBtn = document.getElementById('scrubPlayBtn');
            
            if (state.running) {
                btn.innerHTML = '<i class="fas fa-pause"></i> Pause';
                btn.classList.replace('bg-blue-600', 'bg-amber-500');
                btn.classList.replace('hover:bg-blue-700', 'hover:bg-amber-600');
                scrubBtn.innerHTML = '<i class="fas fa-pause"></i>';
            } else {
                btn.innerHTML = '<i class="fas fa-play"></i> Start';
                btn.classList.replace('bg-amber-500', 'bg-blue-600');
                btn.classList.replace('hover:bg-amber-600', 'hover:bg-blue-700');
                scrubBtn.innerHTML = '<i class="fas fa-play"></i>';
            }
        }

        function toggleDirection() {
            state.params.positiveUp = !state.params.positiveUp;
            const btn = document.getElementById('dirBtn');
            if (state.params.positiveUp) {
                btn.innerHTML = '<i class="fas fa-long-arrow-alt-up"></i> Positive: UP';
                btn.classList.remove('bg-red-50', 'text-red-700', 'border-red-200');
                btn.classList.add('bg-gray-100');
            } else {
                btn.innerHTML = '<i class="fas fa-long-arrow-alt-down"></i> Positive: DOWN';
                btn.classList.remove('bg-gray-100');
                btn.classList.add('bg-red-50', 'text-red-700', 'border-red-200');
            }
            drawFrame();
        }

        function setPreset(type) {
            state.running = false;
            updatePlayButton();
            state.currentTime = 0;

            let y0 = 0, v0 = 0, a = 0, e = 0.8, jerk = 0;

            switch(type) {
                case 'constV':
                    y0 = 10; v0 = 10; a = 0;
                    break;
                case 'constA':
                    y0 = 0; v0 = 0; a = 5;
                    break;
                case 'incAccel':
                    y0 = 0; v0 = 0; a = 1; jerk = 1.0;
                    break;
                case 'decAccel':
                    y0 = 0; v0 = 0; a = 6; jerk = -1.0;
                    break;
                case 'drop':
                    y0 = 90; v0 = 0; a = -9.8; e = 0;
                    break;
                case 'throw':
                    y0 = 0; v0 = 40; a = -10; e = 0; 
                    break;
                case 'bounceElastic':
                    y0 = 80; v0 = 0; a = -9.8; e = 1.0;
                    break;
                case 'bounceInelastic':
                    y0 = 80; v0 = 0; a = -9.8; e = 0.7;
                    break;
            }

            document.getElementById('input_y0').value = y0;
            document.getElementById('input_v0').value = v0;
            document.getElementById('input_a').value = a;
            document.getElementById('input_e').value = e;
            
            state.params.preserveJerk = true;
            state.params.jerk = jerk;
            
            updateParams();
        }

        function scrub(percent) {
            state.running = false;
            updatePlayButton();
            state.currentTime = (percent / 100) * CONSTANTS.simDuration;
            updateScrubberUI();
            drawFrame();
        }
        
        function jumpToTime(t) {
            state.running = false;
            updatePlayButton();
            state.currentTime = parseFloat(t);
            updateScrubberUI();
            drawFrame();
        }

        function updateScrubberUI() {
            const percent = (state.currentTime / CONSTANTS.simDuration) * 100;
            document.getElementById('timeScrubber').value = percent;
            document.getElementById('timeDisplay').textContent = state.currentTime.toFixed(2) + 's';
        }

        // --- Physics Engine ---

        function runSimulation() {
            state.trajectory = { t: [], y: [], v: [], a: [], d: [], s: [] };
            state.events = [];
            
            let t = 0;
            let y = state.params.y0;
            let v = state.params.v0;
            let currentA = state.params.a;
            let jerk = state.params.jerk || 0;
            let dist = 0;
            const dt = CONSTANTS.dt;

            while (t <= CONSTANTS.simDuration) {
                // Store State
                state.trajectory.t.push(t);
                state.trajectory.y.push(y);
                state.trajectory.v.push(v);
                state.trajectory.a.push(currentA);
                state.trajectory.d.push(dist);
                state.trajectory.s.push(Math.abs(v));

                const prevY = y;
                const prevV = v;

                // Predict Peak
                let nextV = v + currentA * dt;

                // Peak Detection
                if (prevV > 0 && nextV < 0 && Math.abs(currentA) > 0.01) {
                    const dtPeak = -prevV / currentA;
                    const tPeak = t + dtPeak;
                    const yPeak = prevY + prevV * dtPeak + 0.5 * currentA * dtPeak * dtPeak;
                    const distPeak = dist + Math.abs(yPeak - prevY); 

                    state.trajectory.t.push(tPeak);
                    state.trajectory.y.push(yPeak);
                    state.trajectory.v.push(0); 
                    state.trajectory.a.push(currentA);
                    state.trajectory.d.push(distPeak);
                    state.trajectory.s.push(0);

                    state.events.push({ time: tPeak, type: 'peak', vIn: 0, vOut: 0 });
                }

                // Evolve State
                currentA += jerk * dt;
                y += v * dt + 0.5 * currentA * dt * dt;
                v += currentA * dt;
                
                dist += Math.abs(y - prevY);

                // Ground Collision
                if (y < 0) {
                    // Exact Impact Calculation
                    let vImpact = v;
                    let tImpact = t + dt;

                    if (Math.abs(currentA) > 1e-4) {
                        const disc = prevV * prevV - 2 * currentA * prevY;
                        if (disc >= 0) {
                             vImpact = -Math.sqrt(disc);
                             const dtImpact = (vImpact - prevV) / currentA;
                             tImpact = t + dtImpact;
                        }
                    } else if (Math.abs(prevV) > 1e-4) {
                        const dtImpact = -prevY / prevV;
                        tImpact = t + dtImpact;
                        vImpact = prevV;
                    }

                    y = 0;
                    let vAfterBounce = v;

                    if (state.params.restitution > 0 && Math.abs(vImpact) > 1.0) {
                        vAfterBounce = -vImpact * state.params.restitution;
                    } else {
                        if (currentA <= 0) { 
                            vAfterBounce = 0; 
                            currentA = 0; 
                            jerk = 0; 
                            y = 0; 
                            // Do NOT set vImpact = 0 here, we need the record of impact
                        }
                    }
                    
                    v = vAfterBounce;

                    // Ensure we register the "Stop" event if we are stopping (vAfterBounce == 0)
                    // even if vImpact was small (but non-negligible)
                    const isStopping = (Math.abs(vImpact) > 1e-4 && vAfterBounce === 0 && Math.abs(vImpact - vAfterBounce) > 1e-4);
                    
                    if (Math.abs(vImpact) > 0.5 || isStopping) { 
                        state.events.push({ 
                            time: tImpact, 
                            type: 'bounce', // Use bounce type for logic consistency
                            vIn: vImpact, 
                            vOut: vAfterBounce 
                        });
                    }
                }

                t += dt;
            }
            
            renderMarkers();
        }

        function renderMarkers() {
            const container = document.getElementById('timelineMarkers');
            container.innerHTML = '';
            
            state.events.forEach(evt => {
                const percent = (evt.time / CONSTANTS.simDuration) * 100;
                if (percent > 100) return;

                const marker = document.createElement('div');
                marker.className = `event-marker marker-${evt.type}`;
                marker.style.left = `${percent}%`;
                marker.style.pointerEvents = 'auto'; 
                marker.setAttribute('data-label', `${evt.type === 'bounce' ? 'Bounce' : 'Peak'} @ ${evt.time.toFixed(2)}s`);
                
                marker.onclick = (e) => {
                    e.stopPropagation();
                    jumpToTime(evt.time);
                };
                
                container.appendChild(marker);
            });
        }

        function animationLoop() {
            if (!state.running) return;

            state.currentTime += CONSTANTS.dt;
            if (state.currentTime >= CONSTANTS.simDuration) {
                state.currentTime = CONSTANTS.simDuration;
                state.running = false;
                updatePlayButton();
            }

            updateScrubberUI();
            drawFrame();
            
            if (state.running) {
                requestAnimationFrame(animationLoop);
            }
        }

        // --- Exact State Calculation ---

        function getExactState(time) {
            const times = state.trajectory.t;
            let low = 0, high = times.length - 1;
            let index = 0;

            while (low <= high) {
                let mid = Math.floor((low + high) / 2);
                if (times[mid] <= time) {
                    index = mid;
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }

            if (index >= times.length - 1) {
                index = times.length - 1;
                return {
                    y: state.trajectory.y[index],
                    v: state.trajectory.v[index],
                    a: state.trajectory.a[index],
                    index: index
                };
            }

            const t0 = times[index];
            const y0 = state.trajectory.y[index];
            const v0 = state.trajectory.v[index];
            const a0 = state.trajectory.a[index];
            
            const dt = time - t0;
            
            // v = u + at, s = ut + 0.5at^2
            const vExact = v0 + a0 * dt;
            const yExact = y0 + v0 * dt + 0.5 * a0 * dt * dt;

            return {
                y: yExact,
                v: vExact,
                a: a0,
                index: index 
            };
        }

        // --- Drawing ---

        function drawFrame() {
            const current = getExactState(state.currentTime);
            drawAnimation(current.y, current.v);
            drawGraphs(current.index, current);
            updateCalculations(current.index, current);
        }

        function updateCalculations(idx, exactState) {
            const traj = state.trajectory;
            const sign = state.params.positiveUp ? 1 : -1;
            
            const currentVel = exactState.v * sign;
            document.getElementById('calc-disp-grad').textContent = `${currentVel.toFixed(2)} m/s`;

            const currentAcc = exactState.a * sign;
            document.getElementById('calc-vel-grad').textContent = `${currentAcc.toFixed(2)} m/s²`;

            const initialPos = traj.y[0] * sign;
            const currentPos = exactState.y * sign;
            const deltaS = currentPos - initialPos;
            document.getElementById('calc-vel-area').textContent = `${deltaS.toFixed(2)} m`;

            updateAreaCalculationDisplay(idx, sign, exactState);

            const initialVel = traj.v[0] * sign;
            const deltaV = currentVel - initialVel;
            document.getElementById('calc-acc-area').textContent = `${deltaV.toFixed(2)} m/s`;
        }

        function updateAreaCalculationDisplay(idx, sign, exactState) {
            if (Math.abs(state.params.jerk) > 0.001) {
                document.getElementById('calc-vel-formula').innerHTML = 
                    `<div style="margin-top:4px; font-style:italic; color:#9ca3af;">(Non-uniform acceleration: Area calculated via integration)</div>`;
                return;
            }

            const currentTime = state.currentTime;
            
            // Build Boundaries
            let boundaries = [ { time: 0, v: state.trajectory.v[0] * sign } ];
            
            state.events.forEach(e => {
                // Ensure event is included even if exact timing matches
                if (e.time > 0 && e.time <= currentTime) {
                    boundaries.push({
                        time: e.time,
                        type: e.type,
                        vIn: e.vIn * sign,
                        vOut: e.vOut * sign
                    });
                }
            });

            // Add Current Time as final boundary
            boundaries.push({ time: currentTime, v: exactState.v * sign });
            boundaries.sort((a, b) => a.time - b.time);

            let htmlParts = [];
            let hasPrintedFirst = false;

            for (let i = 0; i < boundaries.length - 1; i++) {
                const b1 = boundaries[i];
                const b2 = boundaries[i + 1];

                const dt = b2.time - b1.time;
                if (dt < 0.001) continue; 

                const v1 = (b1.type === 'bounce') ? b1.vOut : (b1.v !== undefined ? b1.v : b1.vOut || 0);
                const v2 = (b2.type === 'bounce') ? b2.vIn : (b2.v !== undefined ? b2.v : b2.vIn || 0);

                // Skip pure resting segments to avoid clutter, but allow tiny values 
                // if they are part of a stopping transition
                if (Math.abs(v1) < 1e-3 && Math.abs(v2) < 1e-3) continue;

                const area = 0.5 * (v1 + v2) * dt;
                
                const isRectangle = Math.abs(v1 - v2) < 0.01;
                const isTriangle = !isRectangle && (Math.abs(v1) < 0.01 || Math.abs(v2) < 0.01);
                
                let partStr = "";
                
                if (isRectangle) {
                    partStr = `(${Math.abs(v1).toFixed(1)} × ${dt.toFixed(1)})`;
                } else if (isTriangle) {
                    const h = (Math.abs(v1) > Math.abs(v2)) ? Math.abs(v1) : Math.abs(v2);
                    partStr = `(0.5 × ${h.toFixed(1)} × ${dt.toFixed(1)})`;
                } else {
                    partStr = `(0.5 × (${Math.abs(v1).toFixed(1)} + ${Math.abs(v2).toFixed(1)}) × ${dt.toFixed(1)})`;
                }

                let lineStr = "";
                if (!hasPrintedFirst) {
                    if (area < 0) lineStr = "- ";
                    hasPrintedFirst = true;
                } else {
                    lineStr = (area >= 0) ? "+ " : "- ";
                }
                
                htmlParts.push(lineStr + partStr);
            }
            
            if (htmlParts.length === 0) {
                 document.getElementById('calc-vel-formula').innerHTML = "";
            } else {
                 const formulaHTML = htmlParts.join('<br>');
                 document.getElementById('calc-vel-formula').innerHTML = formulaHTML;
            }
        }

        function drawAnimation(y, v) {
            const canvas = document.getElementById('animCanvas');
            const ctx = state.animCtx;
            const w = canvas.logicalWidth;
            const h = canvas.logicalHeight;

            ctx.clearRect(0, 0, w, h);

            // Rulers
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 1;
            for(let i=0; i<=100; i+=10) {
                const yPos = h - (i / CONSTANTS.maxY) * (h - 20) - 20; 
                ctx.beginPath();
                ctx.moveTo(0, yPos);
                ctx.lineTo(w, yPos);
                ctx.stroke();
            }

            // Ball
            const radius = 12;
            let visualY = h - (y / CONSTANTS.maxY) * (h - 20) - 20 - radius; 

            // Shadow
            ctx.beginPath();
            ctx.ellipse(w/2, h - 15, radius * (1 - Math.min(y/100, 1)), radius * 0.3 * (1 - Math.min(y/100, 1)), 0, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.fill();

            // Body
            ctx.beginPath();
            ctx.arc(w/2, visualY + radius, radius, 0, Math.PI * 2);
            const gradient = ctx.createRadialGradient(w/2 - 4, visualY + radius - 4, 2, w/2, visualY + radius, radius);
            gradient.addColorStop(0, '#60a5fa');
            gradient.addColorStop(1, '#2563eb');
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = '#1e40af';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Vector
            if (Math.abs(v) > 0.1) {
                const vScale = 2; 
                const vy = -v * vScale; 
                ctx.beginPath();
                ctx.moveTo(w/2 + radius + 5, visualY + radius);
                ctx.lineTo(w/2 + radius + 5, visualY + radius + vy);
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function drawGraphs(currentIndex, exactState) {
            const traj = state.trajectory;
            const sign = state.params.positiveUp ? 1 : -1;

            renderGraph('dispGraph', traj.t, traj.y.map(v => v * sign), '#2563eb', true, currentIndex, exactState.y * sign);
            renderGraph('velGraph', traj.t, traj.v.map(v => v * sign), '#2563eb', true, currentIndex, exactState.v * sign);
            renderGraph('accGraph', traj.t, traj.a.map(v => v * sign), '#2563eb', true, currentIndex, exactState.a * sign);
            renderGraph('distGraph', traj.t, traj.d, '#16a34a', false, currentIndex, null); 
            renderGraph('spdGraph', traj.t, traj.s, '#16a34a', false, currentIndex, Math.abs(exactState.v));
        }

        function renderGraph(canvasId, tData, yData, color, isVector, currentIndex, currentValOverride) {
            const ctx = state.graphs[canvasId];
            const canvas = document.getElementById(canvasId);
            const w = canvas.logicalWidth;
            const h = canvas.logicalHeight;

            ctx.clearRect(0, 0, w, h);

            if (tData.length === 0) return;

            let maxY, minY;

            let dataMax = -Infinity;
            let dataMin = Infinity;
            
            for(let v of yData) {
                if (v > dataMax) dataMax = v;
                if (v < dataMin) dataMin = v;
            }

            if (isVector) {
                let absLimit = Math.max(Math.abs(dataMax), Math.abs(dataMin));
                if (absLimit === 0) absLimit = 10;
                const padding = absLimit * 0.15;
                maxY = absLimit + padding;
                minY = -(absLimit + padding);
            } else {
                let range = dataMax - dataMin;
                if (range === 0) range = 10;
                maxY = dataMax + (range * 0.1);
                minY = dataMin - (range * 0.1);
                if (minY > 0) minY = -(range * 0.05);
                if (dataMin >= 0 && minY < -1) minY = -1;
            }

            const rangeY = maxY - minY;
            const maxT = CONSTANTS.simDuration; 

            const getX = (t) => (t / maxT) * w;
            const getY = (val) => h - ((val - minY) / rangeY) * h;

            // Zero Line
            if (minY <= 0 && maxY >= 0) {
                const zeroY = getY(0);
                ctx.beginPath();
                ctx.moveTo(0, zeroY);
                ctx.lineTo(w, zeroY);
                ctx.strokeStyle = '#9ca3af'; 
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Ghost
            ctx.beginPath();
            ctx.moveTo(getX(tData[0]), getY(yData[0]));
            for (let i = 1; i < tData.length; i++) {
                ctx.lineTo(getX(tData[i]), getY(yData[i]));
            }
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Active Path
            if (currentIndex > 0) {
                ctx.beginPath();
                ctx.moveTo(getX(tData[0]), getY(yData[0]));
                for (let i = 1; i <= currentIndex; i++) {
                    ctx.lineTo(getX(tData[i]), getY(yData[i]));
                }
                
                // Line to Exact
                if (currentValOverride !== null) {
                    ctx.lineTo(getX(state.currentTime), getY(currentValOverride));
                }

                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Dot
                const lastX = getX(state.currentTime);
                const lastVal = (currentValOverride !== null) ? currentValOverride : yData[currentIndex];
                const lastY = getY(lastVal);
                
                ctx.beginPath();
                ctx.arc(lastX, lastY, 4, 0, Math.PI*2);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#374151';
                ctx.font = '10px Inter';
                let labelY = lastY - 10;
                if (labelY < 10) labelY = lastY + 20;
                ctx.fillText(lastVal.toFixed(1), lastX - 10, labelY);
            }
        }
    </script>
</body>
</html>
