<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Mobile & responsive -->
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Wave Simulation</title>
  <style>
    :root{
      --container-max: 100%;
      --radius: 14px;
      --pad: 14px;
      --card-bg: rgba(255,255,255,0.10);
      --glass-border: 1px solid rgba(255,255,255,0.18);
      --text-light: #fff;
      --axis: #000;
      --tick: #666;
      --distance-color: #2196F3;
      --time-color: #4CAF50;
      --dot-color: #F44336;
    }

    /* Base */
    html,body{height:100%}
    body{
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji", "Segoe UI Symbol";
      margin: 0;
      padding: min(3vw, 16px);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: var(--text-light);
    }

    .container{
      max-width: var(--container-max);
      margin: 0 auto;
      background: var(--card-bg);
      border: var(--glass-border);
      border-radius: var(--radius);
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(31,38,135,0.37);
      display: flex;
      flex-direction: column;
      gap: clamp(10px, 2vw, 16px);
      padding: clamp(10px, 2vw, 16px);
    }

    h1{
      text-align: center;
      margin: 0;
      font-size: clamp(1.2rem, 2.5vw, 1.8rem);
      text-shadow: 2px 2px 4px rgba(0,0,0,.3);
    }

    .graphs{
      display: grid;
      gap: clamp(10px, 2vw, 16px);
    }

    .graph{
      background: rgba(0,0,0,0.18);
      border-radius: var(--radius);
      padding: clamp(8px, 1.8vw, 12px);
    }

    .graph-title{
      text-align:center;
      font-weight: 600;
      margin-bottom: 6px;
      font-size: clamp(.9rem, 2vw, 1rem);
    }

    canvas{
      background: rgba(255,255,255,0.97);
      border-radius: 10px;
      box-shadow: 0 4px 14px rgba(0,0,0,.25);
      display:block;
      width: 100%;          /* CSS width — we’ll set JS logical size */
      height: auto;
      touch-action: manipulation;
    }

    .controls{
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px,1fr));
      gap: clamp(8px, 2vw, 14px);
    }

    .control{
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.22);
      border-radius: 10px;
      padding: clamp(8px, 2vw, 12px);
    }

    .control h3{
      margin: 0 0 6px;
      font-size: clamp(.85rem, 2vw, .95rem);
      color: #ffeb3b;
      letter-spacing:.2px;
    }

    .row{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap: 8px;
      margin-bottom: 6px;
      font-size: clamp(.8rem, 1.8vw, .9rem);
      color: #fff;
    }

    input[type="range"]{
      width:100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(255,255,255,0.35);
      -webkit-appearance:none; appearance:none;
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none; appearance:none;
      width: 18px; height: 18px;
      border-radius: 50%;
      background:#ffeb3b;
      box-shadow: 0 1px 3px rgba(0,0,0,.35);
      cursor:pointer;
      touch-action: none;
    }
    input[type="range"]::-moz-range-thumb{
      width: 18px; height: 18px;
      border-radius: 50%;
      background:#ffeb3b; border:none;
      box-shadow: 0 1px 3px rgba(0,0,0,.35);
      cursor:pointer;
    }

    .buttons{
      display:flex;
      gap: 10px;
      justify-content:center;
      flex-wrap: wrap;
    }
    button{
      background: linear-gradient(45deg, #ff6b6b, #ee5a24);
      color:#fff; border:none;
      padding: 10px 16px;
      border-radius: 20px;
      font-weight: 700;
      font-size: clamp(.85rem, 2vw, .95rem);
      letter-spacing:.4px;
      box-shadow: 0 2px 8px rgba(0,0,0,.25);
      cursor:pointer;
      min-width: 140px;
      touch-action: manipulation;
    }
    button:hover{ transform: translateY(-1px); box-shadow: 0 3px 12px rgba(0,0,0,.35); }
    button:active{ transform: translateY(0); }
    .reset{ background: linear-gradient(45deg,#9c27b0,#673ab7); }

    .info{
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.22);
      border-radius: 10px;
      padding: clamp(8px, 2vw, 12px);
      font-size: clamp(.8rem, 1.8vw, .9rem);
      text-align:center;
    }

    /* Mobile refinements */
    @media (max-width: 600px){
      .container{ padding: 12px; }
      .graph{ padding: 10px; }
      canvas{ box-shadow: 0 2px 8px rgba(0,0,0,.2); }
      .buttons button{ min-width: 44%; padding: 12px 14px; }
    }

    /* Respect users who prefer less motion */
    @media (prefers-reduced-motion: reduce){
      *{ animation-duration: .001ms !important; animation-iteration-count: 1 !important; transition-duration: .001ms !important; scroll-behavior: auto !important; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Wave Simulation</h1>

    <div class="graphs">
      <div class="graph">
        <div class="graph-title">Displacement vs Distance</div>
        <!-- Logical size set by JS on load/resize -->
        <canvas id="distanceCanvas"></canvas>
      </div>
      <div class="graph">
        <div class="graph-title">Displacement vs Time</div>
        <canvas id="timeCanvas"></canvas>
      </div>
    </div>

    <div class="controls">
      <div class="control">
        <h3>Amplitude</h3>
        <div class="row"><span>Amp</span><span id="amplitudeValue">50</span></div>
        <input type="range" id="amplitudeSlider" min="10" max="100" value="50" />
      </div>

      <div class="control">
        <h3>Frequency</h3>
        <div class="row"><span>Freq (Hz)</span><span id="frequencyValue">1.0</span></div>
        <input type="range" id="frequencySlider" min="0.1" max="3.0" step="0.1" value="1.0" />
      </div>

      <div class="control">
        <h3>Wave Speed</h3>
        <div class="row"><span>Speed</span><span id="speedValue">100</span></div>
        <input type="range" id="speedSlider" min="20" max="200" value="100" />
      </div>

      <div class="control">
        <h3>Wavelength</h3>
        <div class="row"><span>λ (mm)</span><span id="wavelengthValue">200</span></div>
        <input type="range" id="wavelengthSlider" min="80" max="400" step="5" value="200" />
      </div>
    </div>

    <div class="buttons">
      <button id="animateBtn">Start Animation</button>
      <button class="reset" id="resetBtn">Reset</button>
    </div>

    <div class="info">
      <strong>Tip:</strong> On mobile, rotate to landscape for a wider view. The lower graph starts at t = 0 on the left and scrolls once the red dot reaches the right edge.
    </div>
  </div>

  <script>
    class WaveSimulation {
      constructor() {
        // DOM
        this.distanceCanvas = document.getElementById('distanceCanvas');
        this.timeCanvas = document.getElementById('timeCanvas');
        this.distanceCtx = this.distanceCanvas.getContext('2d');
        this.timeCtx = this.timeCanvas.getContext('2d');
        this.realTime = 0;         // seconds of real (wall-clock) time


        // State
        this.amplitude = 50;
        this.frequency = 1.0;      // Hz
        this.speed = 100;          // UI factor
        this.wavelengthPx = 200;   // px per λ
        this.maxYDisplay = 100;    // y tick range
        this.timeWindowSec = 5.0;  // visible width (sec)
        this.sampleEverySec = 1/120;
        this.lambdaScale = this.wavelengthPx / (this.speed / this.frequency); // = 200 / (100/1) = 2
        // Animation
        this.isAnimating = false;
        this.animationId = null;
        this.tNow = 0;
        this._lastPerf = null;
        this._sampleAccumulator = 0;
        this.timeData = [];

        // Init
        this.bindUI();
        this.resizeAll(); // sets up canvas sizing & DPR scaling
        this.drawInitialWaves();

        // Responsive: throttle resize
        let resizeTimer;
        window.addEventListener('resize', () => {
          clearTimeout(resizeTimer);
          resizeTimer = setTimeout(() => {
            this.resizeAll();
            // redraw current frame
            if (this.isAnimating) {
              // let RAF draw; do nothing
            } else {
              this.drawInitialWaves();
            }
          }, 120);
        }, { passive: true });
      }

      bindUI(){
        const amp = document.getElementById('amplitudeSlider');
        const freq = document.getElementById('frequencySlider');
        const spd  = document.getElementById('speedSlider');
        const wl   = document.getElementById('wavelengthSlider');
        const animateBtn = document.getElementById('animateBtn');
        const resetBtn   = document.getElementById('resetBtn');

        amp.addEventListener('input', e=>{
          this.amplitude = +e.target.value;
          document.getElementById('amplitudeValue').textContent = this.amplitude;
          if(!this.isAnimating) this.drawInitialWaves();
        });

        freq.addEventListener('input', e=>{
          this.frequency = +e.target.value;
          document.getElementById('frequencyValue').textContent = this.frequency.toFixed(1);
          this.recomputeWavelengthFromVF();
          if(!this.isAnimating) this.drawInitialWaves();
        });

        spd.addEventListener('input', e=>{
          this.speed = +e.target.value;
          document.getElementById('speedValue').textContent = this.speed;
          this.recomputeWavelengthFromVF();
          if(!this.isAnimating) this.drawInitialWaves();
        });

        wl.addEventListener('input', e=>{
          this.wavelengthPx = +e.target.value;
          document.getElementById('wavelengthValue').textContent = this.wavelengthPx.toFixed(0);

          // CHANGE: adjust frequency so v = f λ while speed is unchanged
          this.recomputeFrequencyFromVL();

          if(!this.isAnimating) this.drawInitialWaves();
        });


        animateBtn.addEventListener('click', ()=> this.toggleAnimation());
        resetBtn.addEventListener('click', ()=> this.reset());
      }

      // --- Responsive canvas sizing ---
      resizeAll(){
        // Choose logical widths based on container width
        const container = document.querySelector('.container');
        const maxW = Math.min(container.clientWidth - 2*24, 1200); // padding guard
        // Aspect ratio: keep graphs readable on phones
        const h1 = Math.round(Math.max(140, maxW * 0.22)); // distance graph
        const h2 = Math.round(Math.max(140, maxW * 0.22)); // time graph

        this.setCanvasSize(this.distanceCanvas, this.distanceCtx, maxW, h1);
        this.setCanvasSize(this.timeCanvas, this.timeCtx, maxW, h2);
      }

      setCanvasSize(canvas, ctx, cssW, cssH){
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        canvas._cssW = cssW;
        canvas._cssH = cssH;
        canvas.style.width  = cssW + 'px';
        canvas.style.height = cssH + 'px';
        canvas.width  = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0); // 1 unit = 1 CSS px
      }

      sizeOf(canvas){ return { W: canvas._cssW|0, H: canvas._cssH|0 }; }

      // --- Clean white background + single horizontal axis line ---
      drawAxisLine(ctx, canvas){
        const { W, H } = this.sizeOf(canvas);
        ctx.clearRect(0,0,W,H);
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(0, H/2); ctx.lineTo(W, H/2); ctx.stroke();
      }

      drawAxes(ctx, canvas, xLabel, yLabel){
        const { W, H } = this.sizeOf(canvas);
        // y-label (left, vertical)
        ctx.save();
        ctx.fillStyle = '#333';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.translate(14, H/2);
        ctx.rotate(-Math.PI/2);
        ctx.fillText(yLabel, 0, 0);
        ctx.restore();

        // y ticks (left of canvas)
        ctx.font = '10px Arial';
        ctx.fillStyle = '#666';
        const steps = 4;
        for(let i=-steps;i<=steps;i++){
          if(i===0) continue;
          const y = H/2 - (i * this.maxYDisplay / steps);
          const val = (i * this.maxYDisplay / steps).toFixed(0);
          if (y > 12 && y < H-28){
            ctx.textAlign = 'right';
            ctx.fillText(val, 28, y+3);
          }
        }
        // origin label
        ctx.textAlign = 'right';
        ctx.fillText('0', 28, H/2 + 3);

        // x-label (bottom right—small)
        ctx.textAlign = 'right';
        ctx.fillStyle = '#333';
        ctx.font = '11px Arial';
        ctx.fillText(xLabel, W - 6, H - 6);
      }

      drawMovingTimeAxisTicks(ctx, canvas){
        const { W, H } = this.sizeOf(canvas);
        ctx.save();
        ctx.font = '10px Arial';
        ctx.fillStyle = '#666';
        ctx.textAlign = 'center';

        const divisions = 10;
        const stepPx = W / divisions;

        // fixed [0, window] then sliding
        const tRight = (this.realTime < this.timeWindowSec) ? this.timeWindowSec : this.realTime;
        const tLeft  = Math.max(0, tRight - this.timeWindowSec);


        const labelY = H/2 + 14; // directly below axis line
        for(let i=0;i<=divisions;i++){
          const x = i * stepPx;
          const alpha = i / divisions;
          const t = tLeft + alpha * (tRight - tLeft);
          ctx.fillText(`${t.toFixed(1)}s`, x, labelY);
        }
        ctx.restore();
      }

      // --- Waves ---
      drawDistanceWave(){
        const ctx = this.distanceCtx, canvas = this.distanceCanvas;
        const { W, H } = this.sizeOf(canvas);

        this.drawAxisLine(ctx, canvas);
        this.drawAxes(ctx, canvas, 'Distance', 'Displacement');

        // λ markers just under axis
        ctx.save();
        ctx.font = '10px Arial';
        ctx.fillStyle = '#666';
        for(let i=0; i * this.wavelengthPx < W; i++){
          const x = Math.round(i * this.wavelengthPx);
          if (x > 30 && x < W - 30) ctx.fillText(`${i}λ`, x, H/2 + 14);
        }
        ctx.restore();

        // waveform
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--distance-color') || '#2196F3';
        ctx.lineWidth = 3;
        ctx.beginPath();
        const k = (2*Math.PI) / this.wavelengthPx;
        const omega = 2*Math.PI*this.frequency;
        for(let x=0;x<W;x++){
          const y = H/2 - this.amplitude * Math.sin(k*x - omega*this.tNow);
          if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();

        // reference point & amplitude line
        const refX = Math.min(200, Math.max(40, Math.round(W*0.28))); // keep sensible on mobile
        const refY = H/2 - this.amplitude * Math.sin(k*refX - omega*this.tNow);
        ctx.fillStyle = '#F44336';
        ctx.beginPath(); ctx.arc(refX, refY, 6, 0, Math.PI*2); ctx.fill();

        ctx.strokeStyle = 'rgba(33,150,243,0.35)';
        ctx.setLineDash([6,4]);
        ctx.beginPath(); ctx.moveTo(0, H/2 - this.amplitude); ctx.lineTo(W, H/2 - this.amplitude); ctx.stroke();
        ctx.setLineDash([]);
      }

      drawTimeWave(){
        const ctx = this.timeCtx, canvas = this.timeCanvas;
        const { W, H } = this.sizeOf(canvas);

        this.drawAxisLine(ctx, canvas);
        this.drawAxes(ctx, canvas, 'Time', 'Displacement');
        this.drawMovingTimeAxisTicks(ctx, canvas);

        // time window
        const tMax = (this.realTime < this.timeWindowSec) ? this.timeWindowSec : this.realTime;
        const tMin = Math.max(0, tMax - this.timeWindowSec);


        // prune & guard
        while(this.timeData.length && this.timeData[0].t < tMin) this.timeData.shift();
        const range = (tMax - tMin);
        if(!this.timeData.length || range <= 0) return;

        const mapX = t => ((t - tMin) / (tMax - tMin)) * W;

        // trace
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--time-color') || '#4CAF50';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(mapX(this.timeData[0].t), H/2 - this.timeData[0].y);
        for(let i=1;i<this.timeData.length;i++){
          const d = this.timeData[i];
          ctx.lineTo(mapX(d.t), H/2 - d.y);
        }
        ctx.stroke();

        // red dot at current t
        const omega = 2 * Math.PI * this.frequency;
        const yNow = this.amplitude * Math.sin(-omega * this.tNow);  // sim time
        const xNow = mapX(this.realTime);                            // real time
        ctx.beginPath(); ctx.arc(xNow, H/2 - yNow, 6, 0, Math.PI*2); ctx.fill();

      }

      drawInitialWaves(){
        // distance static frame
        this.drawDistanceWave();

        // time preview from 0..window
        const ctx = this.timeCtx, canvas = this.timeCanvas;
        const { W, H } = this.sizeOf(canvas);
        this.drawAxisLine(ctx, canvas);
        this.drawAxes(ctx, canvas, 'Time', 'Displacement');
        // ticks under axis for 0..window
        ctx.save();
        ctx.font = '10px Arial';
        ctx.fillStyle = '#666';
        ctx.textAlign = 'center';
        const divisions = 10, step = W/divisions, labelY = H/2 + 14;
        for(let i=0;i<=divisions;i++){
          const t = (i/divisions) * this.timeWindowSec;
          ctx.fillText(`${t.toFixed(1)}s`, i*step, labelY);
        }
        ctx.restore();

        ctx.strokeStyle = '#4CAF50';
        ctx.lineWidth = 3;
        ctx.beginPath();
        const omega = 2*Math.PI*this.frequency;
        for(let x=0;x<W;x++){
          const t = (x/W) * this.timeWindowSec;
          const y = H/2 - this.amplitude * Math.sin(omega * t);
          if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();
      }
    
    recomputeWavelengthFromVF() {
      this.wavelengthPx = this.lambdaScale * (this.speed / this.frequency);
      // keep the slider + label in sync
      const wlSlider = document.getElementById('wavelengthSlider');
      const wlLabel  = document.getElementById('wavelengthValue');
      if (wlSlider) wlSlider.value = this.wavelengthPx.toFixed(0);
      if (wlLabel)  wlLabel.textContent = this.wavelengthPx.toFixed(0);
    }
    recomputeFrequencyFromVL() {
      this.frequency = (this.lambdaScale * this.speed) / this.wavelengthPx;    
      const freqSlider = document.getElementById('frequencySlider');
      const freqLabel  = document.getElementById('frequencyValue');
      if (freqSlider) freqSlider.value = this.frequency.toFixed(1);
      if (freqLabel)  freqLabel.textContent = this.frequency.toFixed(1);
    }

      // --- Animation loop ---
      animate = () => {
        const now = performance.now();
        if (this._lastPerf == null) this._lastPerf = now;
        const dtReal = (now - this._lastPerf) / 1000;   // real seconds since last frame
        this._lastPerf = now;

        const dtSim = dtReal * (this.speed / 100);      // simulation time scaled by speed
        this.realTime += dtReal;                         // advance real time
        this.tNow     += dtSim;                          // advance simulated time

        const omega = 2 * Math.PI * this.frequency;

        // sample at a fixed real-time cadence
        this._sampleAccumulator += dtReal;
        while (this._sampleAccumulator >= this.sampleEverySec) {
          const y = this.amplitude * Math.sin(-omega * this.tNow);   // phase uses sim time
          this.timeData.push({ t: this.realTime, y });               // x-axis uses real time
          this._sampleAccumulator -= this.sampleEverySec;
        }


        this.drawDistanceWave();
        this.drawTimeWave();

        if(this.isAnimating) this.animationId = requestAnimationFrame(this.animate);
      }

      toggleAnimation(){
        const btn = document.getElementById('animateBtn');
        if(this.isAnimating){
          this.isAnimating = false;
          cancelAnimationFrame(this.animationId);
          btn.textContent = 'Start Animation';
          btn.style.background = 'linear-gradient(45deg, #ff6b6b, #ee5a24)';
        } else {
          this.isAnimating = true;
          this.timeData = [{ t: 0, y: 0 }];
          this.tNow = 0;
          this.realTime = 0;  
          this._lastPerf = null;
          this._sampleAccumulator = 0;
          btn.textContent = 'Stop Animation';
          btn.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
          this.animationId = requestAnimationFrame(this.animate);
        }
      }

      reset(){
        if(this.isAnimating) this.toggleAnimation();
        this.amplitude = 50; this.frequency = 1.0; this.speed = 100; this.wavelengthPx = 200;
        this.tNow = 0; this.timeData = []; this.realTime = 0; this._lastPerf = null; this._sampleAccumulator = 0;

        document.getElementById('amplitudeSlider').value = 50;
        document.getElementById('amplitudeValue').textContent = '50';
        document.getElementById('frequencySlider').value = 1.0;
        document.getElementById('frequencyValue').textContent = '1.0';
        document.getElementById('speedSlider').value = 100;
        document.getElementById('speedValue').textContent = '100';
        document.getElementById('wavelengthSlider').value = 200;
        document.getElementById('wavelengthValue').textContent = '200';

        this.drawInitialWaves();
      }
    }

    // Boot
    window.addEventListener('load', ()=> new WaveSimulation());
  </script>
</body>
</html>
