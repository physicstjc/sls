<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dropping Spheres Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
        }
        
        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 20px;
            max-width: 1100px;
            width: 100%;
            height: 500px;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        h1 {
            font-size: 20px;
            color: #424242;
            font-weight: 500;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .toggle-container {
            display: flex;
            align-items: right;
            gap: 10px;
            font-size: 12px;
        }
        
        .toggle {
            position: relative;
            width: 48px;
            height: 24px;
            background: #ccc;
            border-radius: 24px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .toggle.active {
            background: #4CAF50;
        }
        
        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .toggle.active .toggle-slider {
            transform: translateX(24px);
        }
        
        .btn {
            background: #6200EA;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            text-transform: uppercase;
            transition: background 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .btn:hover {
            background: #7C4DFF;
        }
        
        .zoom-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .zoom-btn {
            background: #2196F3;
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .zoom-btn:hover {
            background: #42A5F5;
        }
        
        .zoom-label {
            font-size: 14px;
            color: #666;
            min-width: 50px;
            text-align: center;
        }
        
        .main-content {
            display: flex;
            gap: 15px;
            flex: 1;
            min-height: 0;
        }
        
        .panel {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }
        
        .panel-title {
            font-size: 16px;
            color: #616161;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        canvas {
            background: white;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .fbd-panel {
            flex: 1;
        }
        
        .graph-panel {
            flex: 1.5;
        }
        
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 8px;
            font-size: 14px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 16px;
            height: 3px;
            border-radius: 2px;
        }
        
        .info-display {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.95);
            padding: 10px;
            border-radius: 8px;
            font-size: 13px;
            color: #333;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .status-display {
            background: rgba(255,255,255,0.95);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            color: #333;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin: 0 20px;
            min-width: 450px;
            text-align: center;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                padding: 5px;
                align-items: flex-start;
            }
            
            .container {
                height: auto;
                min-height: 90vh;
                padding: 10px;
                margin-top: 10px;
            }
            
            .header {
                flex-direction: column;
                gap: 15px;
                align-items: stretch;
                text-align: center;
            }
            
            h1 {
                font-size: 18px;
                margin-bottom: 10px;
            }
            
            .controls {
                flex-wrap: wrap;
                justify-content: center;
                gap: 10px;
            }
            
            .status-display {
                margin: 0;
                min-width: auto;
                font-size: 12px;
                padding: 8px 12px;
            }
            
            .main-content {
                flex-direction: column;
                gap: 10px;
            }
            
            .panel {
                padding: 8px;
            }
            
            .panel-title {
                font-size: 14px;
            }
            
            .legend {
                justify-content: center;
                gap: 15px;
                font-size: 12px;
            }
        }
        
        @media (max-width: 480px) {
            .container {
                padding: 10px;
                border-radius: 8px;
            }
            
            h1 {
                font-size: 12px;
            }
            
            .controls {
                gap: 8px;
            }
            
            .btn {
                padding: 6px 12px;
                font-size: 14px;
            }
            
            .zoom-btn {
                width: 20px;
                height: 20px;
                font-size: 14px;
            }
            
            .zoom-label {
                font-size: 12px;
                min-width: 40px;
            }
            
            .status-display {
                font-size: 11px;
                padding: 6px 10px;
            }
            
            .legend {
                gap: 10px;
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Dropping Spheres Simulation</h1>
            <div class="status-display" id="statusDisplay"></div>
            <div class="controls">
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoomOut">−</button>
                    <span class="zoom-label" id="zoomLabel">100%</span>
                    <button class="zoom-btn" id="zoomIn">+</button>
                </div>
                <div class="toggle-container">
                    <label for="airToggle">Air Resistance:</label>
                    <div class="toggle" id="airToggle">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
                <button class="btn" id="startPauseBtn">Start</button>
                <button class="btn" id="resetBtn">Reset</button>
            </div>
        </div>
        
        <div class="main-content">
            <div class="panel fbd-panel">
                <div class="panel-title">Free Body Diagrams</div>
                <canvas id="fbdCanvas"></canvas>
            </div>
            
            <div class="panel graph-panel">
                <div class="panel-title">Velocity vs Time</div>
                <canvas id="graphCanvas"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF6B6B;"></div>
                        <span>Light (2 kg)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4ECDC4;"></div>
                        <span>Heavy (8 kg)</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Canvas setup
        const fbdCanvas = document.getElementById('fbdCanvas');
        const graphCanvas = document.getElementById('graphCanvas');
        const fbdCtx = fbdCanvas.getContext('2d');
        const graphCtx = graphCanvas.getContext('2d');

        const statusDisplay = document.getElementById('statusDisplay');
        
        // Responsive canvas sizing
        function resizeCanvases() {
            const fbdPanel = document.querySelector('.fbd-panel');
            const graphPanel = document.querySelector('.graph-panel');
            const isMobile = window.innerWidth <= 768;
            
            fbdCanvas.width = fbdPanel.offsetWidth - 20;
            graphCanvas.width = graphPanel.offsetWidth - 20;
            
            if (isMobile) {
                // Smaller heights for mobile stacked layout
                fbdCanvas.height = Math.min(250, window.innerHeight * 0.3);
                graphCanvas.height = Math.min(200, window.innerHeight * 0.25);
            } else {
                // Desktop heights
                fbdCanvas.height = 330;
                graphCanvas.height = 280;
            }
        }
        
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);
        
        // Physics constants
        const g = 9.8; // m/s^2
        const dt = 0.016; // 60 fps
        
        // Realistic air resistance parameters
        const airDensity = 1.225; // kg/m³ (air density at 15°C)
        const dragCoeff = 0.47; // Drag coefficient for smooth sphere
        const sphereRadius = 0.15; // 15cm radius spheres (more realistic for 2kg and 8kg masses)
        const crossSectionalArea = Math.PI * sphereRadius * sphereRadius; // m²
        const k = 0.5 * airDensity * dragCoeff * crossSectionalArea; // Air resistance coefficient
        
        // Zoom control
        let zoomLevel = 0.75;
        const zoomStep = 0.25;
        const minZoom = 0.25;
        const maxZoom = 3.0;
        
        // Sphere objects
        class Sphere {
            constructor(mass, color, name) {
                this.mass = mass;
                this.color = color;
                this.name = name;
                this.vy = 0;
                this.velocityHistory = [];
                this.timeHistory = [];
            }
            
            reset() {
                this.vy = 0;
                this.velocityHistory = [0];
                this.timeHistory = [0];
            }
            
            update(airResistance, time) {
                let acceleration = g;
                
                if (airResistance && this.vy > 0) {
                    // Quadratic drag: F_air = -0.5 * ρ * Cd * A * v²
                    // a = g - (k * v²) / m, where k = 0.5 * ρ * Cd * A
                    const dragForce = k * this.vy * this.vy;
                    acceleration = g - dragForce / this.mass;
                }
                
                this.vy += acceleration * dt;
                
                // Store history for graph
                this.velocityHistory.push(this.vy);
                this.timeHistory.push(time);
            }
        }
        
        // Create spheres
        const sphere1 = new Sphere(2, '#FF6B6B', 'Light');
        const sphere2 = new Sphere(8, '#4ECDC4', 'Heavy');
        
        // Simulation state
        let animationTime = 0;
        let airResistance = false;
        let isRunning = false;
        let animationId = null;
        
        // Controls
        const airToggle = document.getElementById('airToggle');
        const resetBtn = document.getElementById('resetBtn');
        const startPauseBtn = document.getElementById('startPauseBtn');
        const zoomInBtn = document.getElementById('zoomIn');
        const zoomOutBtn = document.getElementById('zoomOut');
        const zoomLabel = document.getElementById('zoomLabel');
        
        airToggle.addEventListener('click', () => {
            airResistance = !airResistance;
            airToggle.classList.toggle('active');
            reset();
        });
        
        resetBtn.addEventListener('click', reset);
        
        startPauseBtn.addEventListener('click', () => {
            if (isRunning) {
                pause();
            } else {
                start();
            }
        });
        
        zoomInBtn.addEventListener('click', () => {
            if (zoomLevel < maxZoom) {
                zoomLevel = Math.min(zoomLevel + zoomStep, maxZoom);
                updateZoomLabel();
                drawFBD();
            }
        });
        
        zoomOutBtn.addEventListener('click', () => {
            if (zoomLevel > minZoom) {
                zoomLevel = Math.max(zoomLevel - zoomStep, minZoom);
                updateZoomLabel();
                drawFBD();
            }
        });
        
        function updateZoomLabel() {
            // Display zoom as if 0.75 is 100%
            const displayZoom = (zoomLevel / 0.75) * 100;
            zoomLabel.textContent = Math.round(displayZoom) + '%';
        }
        
        function reset() {
            pause();
            sphere1.reset();
            sphere2.reset();
            animationTime = 0;
            drawFBD();
            drawGraph();
            updateInfo();
        }
        
        function start() {
            if (!isRunning) {
                isRunning = true;
                startPauseBtn.textContent = 'Pause';
                animate();
            }
        }
        
        function pause() {
            if (isRunning) {
                isRunning = false;
                startPauseBtn.textContent = 'Start';
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }
        }
        
        // Update status display
        function updateInfo() {
            // Update top status display
            let statusHtml = `<strong>Current Velocities:</strong> `;
            statusHtml += `<span style="color: #FF6B6B;">Light: ${sphere1.vy.toFixed(1)} m/s</span> | `;
            statusHtml += `<span style="color: #4ECDC4;">Heavy: ${sphere2.vy.toFixed(1)} m/s</span>`;
            
            if (airResistance) {
                statusHtml += `<br><strong>Terminal Velocities:</strong> `;
                statusHtml += `<span style="color: #FF6B6B;">Light: ${Math.sqrt(2 * sphere1.mass * g / k).toFixed(1)} m/s</span> | `;
                statusHtml += `<span style="color: #4ECDC4;">Heavy: ${Math.sqrt(2 * sphere2.mass * g / k).toFixed(1)} m/s</span>`;
            }
            
            statusDisplay.innerHTML = statusHtml;
        }
        
        // Draw functions
        function drawFBD() {
            fbdCtx.clearRect(0, 0, fbdCanvas.width, fbdCanvas.height);
            
            // Draw two FBDs side by side
            const centerY = fbdCanvas.height / 2;
            drawSingleFBD(fbdCtx, sphere1, fbdCanvas.width * 0.25, centerY);
            drawSingleFBD(fbdCtx, sphere2, fbdCanvas.width * 0.75, centerY);
        }
        
        function drawSingleFBD(ctx, sphere, x, y) {
            const scale = 2.0 * zoomLevel; // Reduced base scale for better fit
            const sphereRadius = 15 * Math.sqrt(zoomLevel);
            
            // Draw vectors first (behind sphere)
            // Gravity force (always present)
            const gravityForce = sphere.mass * g;
            drawVector(ctx, x, y, 0, gravityForce * scale, '#9C27B0', 'Fg = ' + gravityForce.toFixed(1) + 'N');
            
            // Air resistance (if enabled and moving)
            if (airResistance && sphere.vy > 0) {
                const airForce = k * sphere.vy * sphere.vy;
                drawVector(ctx, x, y, 0, -airForce * scale, '#2196F3', 'Fair = ' + airForce.toFixed(1) + 'N');
            }
            
            // Net acceleration - positioned to the side
            let acceleration = g;
            if (airResistance && sphere.vy > 0) {
                const dragForce = k * sphere.vy * sphere.vy;
                acceleration = g - dragForce / sphere.mass;
            }
            
            // Position acceleration vector to the side
            const accelX = x + (45 * Math.sqrt(zoomLevel));
            drawVector(ctx, accelX, y, 0, acceleration * scale, '#FF9800', 'a = ' + acceleration.toFixed(1) + 'm/s²');
            
            // Draw sphere last (in front of vectors)
            ctx.fillStyle = sphere.color;
            ctx.beginPath();
            ctx.arc(x, y, sphereRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Mass label (on top of sphere)
            ctx.fillStyle = 'white';
            ctx.font = `bold ${13 * Math.sqrt(zoomLevel)}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(sphere.mass + 'kg', x, y + 5 * Math.sqrt(zoomLevel));
        }
        
        function drawVector(ctx, x, y, dx, dy, color, label) {
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2 * Math.sqrt(zoomLevel);
            
            // Draw arrow
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + dx, y + dy);
            ctx.stroke();
            
            // Arrowhead
            const angle = Math.atan2(dy, dx);
            const headLength = 8 * Math.sqrt(zoomLevel);
            ctx.beginPath();
            ctx.moveTo(x + dx, y + dy);
            ctx.lineTo(x + dx - headLength * Math.cos(angle - Math.PI/6), 
                      y + dy - headLength * Math.sin(angle - Math.PI/6));
            ctx.lineTo(x + dx - headLength * Math.cos(angle + Math.PI/6), 
                      y + dy - headLength * Math.sin(angle + Math.PI/6));
            ctx.closePath();
            ctx.fill();
            
            // Label - position based on vector type
            ctx.font = `${13 * Math.sqrt(zoomLevel)}px Arial`;
            const labelOffset = 30 * Math.sqrt(zoomLevel);
            
            // Position labels: force vectors to left, acceleration to right
            let labelX, labelY;
            if (label.includes('a =')) { // Acceleration vector (identified by label content)
                labelX = x + 5;
                labelY = y + dy/2;
                ctx.textAlign = 'left';
            } else if (dy > 0) { // Downward vector (gravity)
                labelX = x - labelOffset;
                labelY = y + dy/2;
                ctx.textAlign = 'right';
            } else if (dy < 0) { // Upward vector (air resistance)
                labelX = x - labelOffset;
                labelY = y + dy/2;
                ctx.textAlign = 'right';
            }
            
            ctx.fillText(label, labelX, labelY);
            ctx.textAlign = 'center'; // Reset text alignment
        }
        
        function drawGraph() {
            graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
            
            const padding = 40;
            const graphWidth = graphCanvas.width - padding * 2;
            const graphHeight = graphCanvas.height - padding * 2;
            
            // Draw axes
            graphCtx.strokeStyle = '#666';
            graphCtx.lineWidth = 1;
            graphCtx.beginPath();
            graphCtx.moveTo(padding, padding);
            graphCtx.lineTo(padding, graphCanvas.height - padding);
            graphCtx.lineTo(graphCanvas.width - padding, graphCanvas.height - padding);
            graphCtx.stroke();
            
            // Labels
            graphCtx.fillStyle = '#666';
            graphCtx.font = '14px Arial';
            graphCtx.textAlign = 'center';
            graphCtx.fillText('Time (s)', graphCanvas.width/2, graphCanvas.height - 10);
            
            graphCtx.save();
            graphCtx.translate(15, graphCanvas.height/2);
            graphCtx.rotate(-Math.PI/2);
            graphCtx.fillText('Velocity (m/s)', 0, 0);
            graphCtx.restore();
            
            // Grid lines
            graphCtx.strokeStyle = '#e0e0e0';
            graphCtx.lineWidth = 0.5;
            graphCtx.font = '12px Arial';
            
            // Calculate dynamic velocity scale
            const maxVelocity = Math.max(
                sphere1.velocityHistory.length > 0 ? Math.max(...sphere1.velocityHistory) : 0,
                sphere2.velocityHistory.length > 0 ? Math.max(...sphere2.velocityHistory) : 0,
                20 // Minimum scale of 20 m/s
            );
            // Round up to nearest 10 for cleaner scale
            const velocityScale = Math.ceil(maxVelocity / 10) * 10;
            
            // Horizontal grid lines
            for (let i = 0; i <= 5; i++) {
                const y = padding + (graphHeight * i / 5);
                graphCtx.beginPath();
                graphCtx.moveTo(padding, y);
                graphCtx.lineTo(graphCanvas.width - padding, y);
                graphCtx.stroke();
                
                // Y-axis labels (dynamic scale)
                graphCtx.fillStyle = '#666';
                graphCtx.textAlign = 'right';
                const velocityValue = velocityScale - (i * velocityScale / 5);
                graphCtx.fillText(velocityValue.toFixed(0), padding - 5, y + 4);
            }
            
            // Calculate time scale for expanding graph
            const maxTime = Math.max(
                sphere1.timeHistory.length > 0 ? sphere1.timeHistory[sphere1.timeHistory.length - 1] : 0,
                sphere2.timeHistory.length > 0 ? sphere2.timeHistory[sphere2.timeHistory.length - 1] : 0,
                10 // Minimum scale of 10 seconds
            );
            const minTime = 0;
            const timeRange = maxTime;
            
            // Vertical grid lines for time
            for (let i = 0; i <= 5; i++) {
                const x = padding + (graphWidth * i / 5);
                graphCtx.beginPath();
                graphCtx.moveTo(x, padding);
                graphCtx.lineTo(x, graphCanvas.height - padding);
                graphCtx.stroke();
                
                // X-axis labels (scaling time axis)
                const timeValue = (i * timeRange / 5);
                graphCtx.fillStyle = '#666';
                graphCtx.textAlign = 'center';
                graphCtx.fillText(timeValue.toFixed(1), x, graphCanvas.height - padding + 15);
            }
            
            // Draw data lines with overlap detection
            drawDataLinesWithOverlap(graphCtx, sphere1, sphere2, padding, graphWidth, graphHeight, velocityScale, timeRange);
        }
        
        function drawDataLinesWithOverlap(ctx, sphere1, sphere2, padding, graphWidth, graphHeight, velocityScale, timeRange) {
            const tolerance = 2; // pixels tolerance for overlap detection
            
            // Helper function to convert data to canvas coordinates
            function toCanvas(time, velocity) {
                const x = padding + (time / timeRange) * graphWidth;
                const y = padding + graphHeight - (velocity / velocityScale) * graphHeight;
                return { x, y };
            }
            
            // Draw sphere1 line segments
            if (sphere1.velocityHistory.length >= 2) {
                ctx.strokeStyle = '#FF6B6B';
                ctx.lineWidth = 2;
                
                for (let i = 1; i < sphere1.velocityHistory.length; i++) {
                    
                    const start1 = toCanvas(sphere1.timeHistory[i-1], sphere1.velocityHistory[i-1]);
                    const end1 = toCanvas(sphere1.timeHistory[i], sphere1.velocityHistory[i]);
                    
                    // Check if this segment overlaps with sphere2
                    let isOverlapping = false;
                    if (i < sphere2.velocityHistory.length) {
                        const start2 = toCanvas(sphere2.timeHistory[i-1], sphere2.velocityHistory[i-1]);
                        const end2 = toCanvas(sphere2.timeHistory[i], sphere2.velocityHistory[i]);
                        
                        const dist1 = Math.abs(start1.y - start2.y);
                        const dist2 = Math.abs(end1.y - end2.y);
                        
                        if (dist1 < tolerance && dist2 < tolerance) {
                            isOverlapping = true;
                        }
                    }
                    
                    ctx.beginPath();
                    ctx.moveTo(start1.x, start1.y);
                    if (isOverlapping) {
                        ctx.setLineDash([4, 4]);
                    } else {
                        ctx.setLineDash([]);
                    }
                    ctx.lineTo(end1.x, end1.y);
                    ctx.stroke();
                }
            }
            
            // Draw sphere2 line segments
            if (sphere2.velocityHistory.length >= 2) {
                ctx.strokeStyle = '#4ECDC4';
                ctx.lineWidth = 2;
                
                for (let i = 1; i < sphere2.velocityHistory.length; i++) {
                    
                    const start2 = toCanvas(sphere2.timeHistory[i-1], sphere2.velocityHistory[i-1]);
                    const end2 = toCanvas(sphere2.timeHistory[i], sphere2.velocityHistory[i]);
                    
                    // Check if this segment overlaps with sphere1
                    let isOverlapping = false;
                    if (i < sphere1.velocityHistory.length) {
                        const start1 = toCanvas(sphere1.timeHistory[i-1], sphere1.velocityHistory[i-1]);
                        const end1 = toCanvas(sphere1.timeHistory[i], sphere1.velocityHistory[i]);
                        
                        const dist1 = Math.abs(start1.y - start2.y);
                        const dist2 = Math.abs(end1.y - end2.y);
                        
                        if (dist1 < tolerance && dist2 < tolerance) {
                            isOverlapping = true;
                        }
                    }
                    
                    ctx.beginPath();
                    ctx.moveTo(start2.x, start2.y);
                    if (isOverlapping) {
                        ctx.setLineDash([4, 4, 0, 4]); // Offset dash pattern
                    } else {
                        ctx.setLineDash([]);
                    }
                    ctx.lineTo(end2.x, end2.y);
                    ctx.stroke();
                }
            }
            
            // Reset line dash
            ctx.setLineDash([]);
        }
        
        // Animation loop
        function animate() {
            if (isRunning) {
                sphere1.update(airResistance, animationTime);
                sphere2.update(airResistance, animationTime);
                animationTime += dt;
                
                drawFBD();
                drawGraph();
                updateInfo();
                
                animationId = requestAnimationFrame(animate);
            }
        }
        
        // Initial draw
        drawFBD();
        drawGraph();
        updateInfo();
    </script>
</body>
</html>