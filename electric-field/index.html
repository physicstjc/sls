<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Electric Field Simulation</title>
<style>
body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 10px; background: linear-gradient(135deg, #1e3c72, #2a5298); color: white; }
.container { width: 100%; max-width: 100%; margin: 0 auto; }
.simulation-area { background: rgba(255,255,255,0.95); border-radius: 15px; padding: 15px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); margin-bottom: 10px; }
canvas { width: 100%; height: auto; max-height: 60vh; border: 2px solid #333; border-radius: 10px; background: radial-gradient(circle at center, #f8f9fa, #e9ecef); cursor: crosshair; }
.controls { display: grid; grid-template-columns: 1fr; gap: 10px; margin-top: 10px; }
.control-group { background: rgba(255,255,255,0.9); padding: 10px; border-radius: 10px; color: #333; box-shadow: 0 4px 15px rgba(0,0,0,0.1); font-size: 14px; }
.control-group h3 { margin: 0 0 10px 0; font-size: 1em; }
button { padding: 10px 20px; font-size: 14px; border-radius: 20px; }
.value-display { font-size: 13px; }
@media (min-width: 600px) { .controls { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); } }
.slider-container { margin: 5px 0; }
label { display: block; margin-bottom: 5px; font-weight: 500; }
input[type="range"] { width: 100%; height: 8px; border-radius: 5px; background: #ddd; outline: none; -webkit-appearance: none; }
input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #2a5298; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; border-radius: 50%; background: #2a5298; cursor: pointer; border: none; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
.value-display { font-weight: bold; color: #2a5298; margin-left: 10px; }
button { padding: 8px 12px; border: none; border-radius: 20px; background: linear-gradient(45deg, #2a5298, #1e3c72); color: white; cursor: pointer; font-size: 16px; font-weight: 600; transition: all 0.3s ease; margin: 5px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.3); }
.info { background: rgba(255,255,255,0.9); padding: 15px; border-radius: 10px; color: #333; margin-top: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
.charge-info { display: flex; align-items: center; gap: 10px; margin: 5px 0; }
.charge-indicator { width: 20px; height: 20px; border-radius: 50%; border: 2px solid; }
.positive { background: #ff4444; border-color: #cc3333; }
.negative { background: #4444ff; border-color: #3333cc; }
.test-positive { background: #44ff44; border-color: #33cc33; }
.test-negative { background: #ffaa44; border-color: #cc8833; }
select { padding: 8px; border: 1px solid #ddd; border-radius: 5px; background: white; font-size: 14px; }
#toggleInstructions { padding: 8px 16px; border: none; border-radius: 10px; background: linear-gradient(45deg, #2a5298, #1e3c72); color: white; cursor: pointer; font-weight: 600; margin-bottom: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.2); transition: all 0.3s ease; }
#toggleInstructions:hover { transform: translateY(-2px); box-shadow: 0 6px 15px rgba(0,0,0,0.3); }
</style>
</head>
<body>
<div class="container">
<h3>Charge moving between two charged spheres</h3>

<div class="simulation-area">
<canvas id="canvas" width="780" height="600"></canvas>

<div class="controls">
<div class="control-group">
<h3>Charge 1</h3>
<div class="slider-container">
<label>Magnitude: <span class="value-display" id="charge1Value">5.0</span> μC</label>
<input type="range" id="charge1" min="-10" max="10" value="5" step="0.1">
</div>
<h3>Charge 2</h3>
<div class="slider-container">
<label>Magnitude: <span class="value-display" id="charge2Value">3.0</span> μC</label>
<input type="range" id="charge2" min="-10" max="10" value="3" step="0.1">
</div>
</div>

<div class="control-group">
<h3>Mobile Charge</h3>
<div class="slider-container">
<label>Type:</label>
<select id="testChargeType">
<option value="positive">Positive (+)</option>
<option value="negative" selected>Negative (-)</option>
</select>
</div>
<div class="slider-container">
<label>Magnitude: <span class="value-display" id="testChargeValue">1.0</span> μC</label>
<input type="range" id="testCharge" min="0.1" max="5" value="1" step="0.1">
</div>
</div>

<div class="control-group">
<h3>Simulation</h3>
<button id="playPause">▶ Play</button>
<button id="reset">↻ Reset</button>
<button id="showField">Show Field Lines</button>
<div class="slider-container">
<label>Speed: <span class="value-display" id="speedValue">25</span>×</label>
<input type="range" id="speed" min="0.1" max="50" value="25" step="0.1">
</div>
</div>
</div>
</div>

<div class="info">
<button id="toggleInstructions">Show Instructions ▼</button>
<div id="instructionsContent" style="display:none;">
<p>• <strong>Drag charges:</strong> Move the red and blue source charges along the horizontal axis.</p>
<p>• <strong>Position test charge:</strong> Click and drag the green/orange test charge anywhere.</p>
<p>• <strong>Set initial velocity:</strong> Hold <strong>Shift</strong>, click the test charge, drag to draw a velocity vector and release to set initial velocity.</p>
<p>• <strong>Adjust magnitudes:</strong> Use sliders to change charge strengths.</p>
<p>• <strong>Run simulation:</strong> Click Play to see the test charge move along the electric field.</p>
<p>• <strong>Pan canvas:</strong> Click and drag anywhere on empty space to move the view.</p>
</div>
</div>
</div>

<script>
let sim;

function resizeCanvas() {
    const canvas = document.getElementById('canvas');
    canvas.width = canvas.parentElement.clientWidth;
    canvas.height = window.innerHeight * 0.4;
    if(sim){
        sim.setInitialPositions();
        sim.centerCanvas();
        sim.draw();
    }
}

window.addEventListener('resize', resizeCanvas);

class ElectricFieldSimulation {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.k = 8.99e3;
        this.dt = 0.016;
        this.visualGain = 1e12;

        this.offsetX = 0;
        this.offsetY = 0;

        this.isPlaying = false;
        this.showFieldLines = false;
        this.animationId = null;
        this.speed = 25;

        this.settingVelocity = false;
        this.velocityOrigin = null;
        this.velocityPreview = null;
        this.velocityScale = 0.06;

        this.isPanning = false;
        this.panStart = null;

        this.setInitialPositions();
        this.centerCanvas();

        this.initializeControls();
        this.initializeEvents();
        this.draw();
    }

    setInitialPositions() {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        this.charge1 = { x: centerX - 150, y: centerY, q: 5e-6, dragging: false };
        this.charge2 = { x: centerX + 150, y: centerY, q: 3e-6, dragging: false };
        this.testCharge = { x: centerX, y: centerY - 120, q: -1e-6, vx:0, vy:0, trail: [], dragging:false };
    }

    centerCanvas() {
        // visually center the canvas elements
        this.offsetX = 0;
        this.offsetY = 0;
    }

    initializeControls() {
        const charge1Slider = document.getElementById('charge1');
        const charge2Slider = document.getElementById('charge2');
        const testChargeSlider = document.getElementById('testCharge');
        const testChargeType = document.getElementById('testChargeType');
        const speedSlider = document.getElementById('speed');

        document.getElementById('charge1Value').textContent = charge1Slider.value;
        document.getElementById('charge2Value').textContent = charge2Slider.value;
        document.getElementById('testChargeValue').textContent = testChargeSlider.value;

        charge1Slider.oninput = () => { this.charge1.q = parseFloat(charge1Slider.value)*1e-6; document.getElementById('charge1Value').textContent = charge1Slider.value; this.draw(); };
        charge2Slider.oninput = () => { this.charge2.q = parseFloat(charge2Slider.value)*1e-6; document.getElementById('charge2Value').textContent = charge2Slider.value; this.draw(); };
        testChargeSlider.oninput = () => { const mag=parseFloat(testChargeSlider.value)*1e-6; const sign=testChargeType.value==='positive'?1:-1; this.testCharge.q = mag*sign; document.getElementById('testChargeValue').textContent = testChargeSlider.value; this.draw(); };
        testChargeType.onchange = () => { const mag=Math.abs(this.testCharge.q); const sign=testChargeType.value==='positive'?1:-1; this.testCharge.q = mag*sign; this.draw(); };
        speedSlider.oninput = () => { this.speed = parseFloat(speedSlider.value); document.getElementById('speedValue').textContent = speedSlider.value; };

        document.getElementById('playPause').onclick = () => this.togglePlayPause();
        document.getElementById('reset').onclick = () => this.reset();
        document.getElementById('showField').onclick = () => this.toggleFieldLines();
    }

    initializeEvents() {
        this.canvas.addEventListener('mousedown', e => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', e => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', e => this.onMouseUp(e));
        this.canvas.addEventListener('mouseleave', e => this.onMouseUp(e));
        this.canvas.addEventListener('touchstart', e => { e.preventDefault(); this.onMouseDown(e.touches[0]); });
        this.canvas.addEventListener('touchmove', e => { e.preventDefault(); this.onMouseMove(e.touches[0]); });
        this.canvas.addEventListener('touchend', e => { e.preventDefault(); this.onMouseUp(e.changedTouches ? e.changedTouches[0] : e); });
    }

    getMousePos(e) {
        const rect = this.canvas.getBoundingClientRect();
        return { x:e.clientX-rect.left-this.offsetX, y:e.clientY-rect.top-this.offsetY };
    }

    isNearCharge(mousePos, charge, radius=25) { const dx=mousePos.x-charge.x; const dy=mousePos.y-charge.y; return Math.sqrt(dx*dx+dy*dy)<radius; }

    onMouseDown(e) {
        const mousePos = this.getMousePos(e);
        if (this.isNearCharge(mousePos,this.charge1)) { this.charge1.dragging=true; this.canvas.style.cursor='grabbing'; }
        else if (this.isNearCharge(mousePos,this.charge2)) { this.charge2.dragging=true; this.canvas.style.cursor='grabbing'; }
        else if (this.isNearCharge(mousePos,this.testCharge)) {
            if (e.shiftKey) { this.settingVelocity=true; this.velocityOrigin={x:this.testCharge.x,y:this.testCharge.y}; this.velocityPreview={x:mousePos.x,y:mousePos.y}; }
            else { this.testCharge.dragging=true; this.testCharge.vx=0; this.testCharge.vy=0; this.testCharge.trail=[]; this.canvas.style.cursor='grabbing'; }
        } else { this.isPanning = true; this.panStart = { x:e.clientX, y:e.clientY }; this.canvas.style.cursor = 'grab'; }
    }

    onMouseMove(e) {
        const mousePos = this.getMousePos(e);
        if (this.charge1.dragging) { this.charge1.x=Math.max(25,Math.min(this.canvas.width-25,mousePos.x)); this.draw(); }
        else if (this.charge2.dragging) { this.charge2.x=Math.max(25,Math.min(this.canvas.width-25,mousePos.x)); this.draw(); }
        else if (this.testCharge.dragging) { this.testCharge.x=Math.max(15,Math.min(this.canvas.width-15,mousePos.x)); this.testCharge.y=Math.max(15,Math.min(this.canvas.height-15,mousePos.y)); this.draw(); }
        else if (this.settingVelocity) { this.velocityPreview={x:Math.max(15,Math.min(this.canvas.width-15,mousePos.x)),y:Math.max(15,Math.min(this.canvas.height-15,mousePos.y))}; this.draw(); }
        else if (this.isPanning) {
            const dx = e.clientX - this.panStart.x;
            const dy = e.clientY - this.panStart.y;
            this.offsetX += dx; this.offsetY += dy;
            this.panStart = {x:e.clientX, y:e.clientY};
            this.draw();
        }
    }

    onMouseUp(e) {
        if (this.settingVelocity) { const mousePos=this.getMousePos(e); this.testCharge.vx=(mousePos.x-this.velocityOrigin.x)*this.velocityScale; this.testCharge.vy=(mousePos.y-this.velocityOrigin.y)*this.velocityScale; this.settingVelocity=false; this.velocityOrigin=null; this.velocityPreview=null; }
        this.charge1.dragging=false; this.charge2.dragging=false; this.testCharge.dragging=false; this.isPanning=false; this.canvas.style.cursor='crosshair';
    }

    calculateElectricField(x,y) {
        let Ex=0,Ey=0;
        const addField = c => { let dx=x-c.x, dy=y-c.y, r=Math.sqrt(dx*dx+dy*dy); if(r<10) r=10; let E=this.k*c.q/(r*r); Ex+=E*dx/r; Ey+=E*dy/r; };
        addField(this.charge1); addField(this.charge2);
        return {Ex,Ey};
    }

    drawFieldLines() {
        const grid = 40;          // spacing of sample points
        const arrow = 10;         // arrow length
        const ctx = this.ctx;

        ctx.save();
        ctx.strokeStyle = 'rgba(80,80,80,0.7)';
        ctx.lineWidth = 1;

        for (let x = grid / 2; x < this.canvas.width; x += grid) {
            for (let y = grid / 2; y < this.canvas.height; y += grid) {
                // convert from screen to simulated coords (remove pan offset)
                const sx = x - this.offsetX;
                const sy = y - this.offsetY;

                const { Ex, Ey } = this.calculateElectricField(sx, sy);
                const mag = Math.hypot(Ex, Ey);
                if (mag < 1e-6) continue;

                // Normalize and scale to arrow size
                const ex = (Ex / mag) * arrow;
                const ey = (Ey / mag) * arrow;

                // Draw arrow in screen coords (add pan offset back)
                const x1 = sx + this.offsetX;
                const y1 = sy + this.offsetY;
                const x2 = x1 + ex;
                const y2 = y1 + ey;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                // arrow head
                const ang = Math.atan2(ey, ex);
                const ah = 5;
                ctx.beginPath();
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 - ah * Math.cos(ang - Math.PI / 6), y2 - ah * Math.sin(ang - Math.PI / 6));
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 - ah * Math.cos(ang + Math.PI / 6), y2 - ah * Math.sin(ang + Math.PI / 6));
                ctx.stroke();
            }
        }
        ctx.restore();
    }

    updateTestCharge() {
        if(this.testCharge.dragging||this.settingVelocity) return;
        const f = this.calculateElectricField(this.testCharge.x,this.testCharge.y);
        const Fx=this.testCharge.q*f.Ex, Fy=this.testCharge.q*f.Ey;
        const sFx=Fx*this.visualGain, sFy=Fy*this.visualGain;
        this.testCharge.vx += sFx*this.dt*this.speed; this.testCharge.vy += sFy*this.dt*this.speed;
        this.testCharge.vx*=0.999; this.testCharge.vy*=0.999;
        let nextX=this.testCharge.x+this.testCharge.vx*this.dt*this.speed, nextY=this.testCharge.y+this.testCharge.vy*this.dt*this.speed;
        [this.charge1,this.charge2].forEach(c=>{const dx=nextX-c.x,dy=nextY-c.y,dist=Math.sqrt(dx*dx+dy*dy); if(dist<40){nextX=this.testCharge.x; nextY=this.testCharge.y; this.testCharge.vx=0; this.testCharge.vy=0;}});
        this.testCharge.x=nextX; this.testCharge.y=nextY;
        this.testCharge.trail.push({x:this.testCharge.x,y:this.testCharge.y});
        if(this.testCharge.trail.length>150) this.testCharge.trail.shift();
    }

    drawCharge(charge, color, label) {
        const ctx = this.ctx;
        const x = charge.x + this.offsetX;
        const y = charge.y + this.offsetY;

        // draw the charge circle
        ctx.beginPath();
        ctx.arc(x, y, 20, 0, 2 * Math.PI);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        ctx.stroke();

        // draw the label text
        ctx.fillStyle = "#000";
        ctx.font = "bold 14px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(label, x, y);
    }


    draw() {
        this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
        if (this.showFieldLines) this.drawFieldLines();
        
        // Calculate and display speed
        const speed = Math.sqrt(this.testCharge.vx**2 + this.testCharge.vy**2);
        this.ctx.fillStyle = '#333';
        this.ctx.font = 'bold 14px Arial';
        this.ctx.textAlign = 'right';
        this.ctx.fillText(`Speed: ${speed.toFixed(2)} m/s`, this.canvas.width - 10, 20);
        
        // trails
        this.ctx.beginPath();
        this.testCharge.trail.forEach((p,i)=>{
            if (i===0) this.ctx.moveTo(p.x+this.offsetX, p.y+this.offsetY);
            else this.ctx.lineTo(p.x+this.offsetX, p.y+this.offsetY);
        });
        this.ctx.strokeStyle = "rgba(0,0,0,0.3)";
        this.ctx.lineWidth = 1;
        this.ctx.stroke();

        // charges
        this.drawCharge(this.charge1, "#ff4444", (this.charge1.q>0?"+":"") + (this.charge1.q*1e6).toFixed(1));
        this.drawCharge(this.charge2, "#ff4444", (this.charge2.q>0?"+":"") + (this.charge2.q*1e6).toFixed(1));
        const testLabel = (this.testCharge.q>0?"+":"-") + (Math.abs(this.testCharge.q*1e6)).toFixed(1);
        const testColor = this.testCharge.q>0 ? "#44ff44" : "#ffaa44";
        this.drawCharge(this.testCharge, testColor, testLabel);

        // velocity preview ...
        if (this.settingVelocity && this.velocityOrigin && this.velocityPreview) {
            this.ctx.beginPath();
            this.ctx.moveTo(this.velocityOrigin.x+this.offsetX, this.velocityOrigin.y+this.offsetY);
            this.ctx.lineTo(this.velocityPreview.x+this.offsetX, this.velocityPreview.y+this.offsetY);
            this.ctx.strokeStyle = "orange";
            this.ctx.lineWidth = 2;
            this.ctx.setLineDash([5,5]);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
        }
    }

    togglePlayPause() { this.isPlaying?this.pause():this.play(); }
    play() { this.isPlaying=true; document.getElementById('playPause').textContent='⏸ Pause'; this.animationLoop(); }
    pause() { this.isPlaying=false; document.getElementById('playPause').textContent='▶ Play'; if(this.animationId) cancelAnimationFrame(this.animationId); }
    reset() { this.pause(); this.setInitialPositions(); this.centerCanvas(); this.testCharge.vx=0; this.testCharge.vy=0; this.testCharge.trail=[]; this.draw(); }
    toggleFieldLines() { this.showFieldLines=!this.showFieldLines; this.draw(); }
    animationLoop() { if(!this.isPlaying) return; this.updateTestCharge(); this.draw(); this.animationId=requestAnimationFrame(()=>this.animationLoop()); }
}

document.getElementById('toggleInstructions').onclick=function(){
    const c=document.getElementById('instructionsContent');
    if(c.style.display==='none'){ c.style.display='block'; this.textContent='Hide Instructions ▲'; }
    else{ c.style.display='none'; this.textContent='Show Instructions ▼'; }
}

window.onload=function(){
    sim = new ElectricFieldSimulation();
    resizeCanvas();
};
</script>
</body>
</html>
